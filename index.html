<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <title>DB-LoadBalancer by amaliujia</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>DB-LoadBalancer</h1>
        <h2>Database, Parallel Computing, Load Balance</h2>

        <section id="downloads">
          <a href="https://github.com/amaliujia/DB-LoadBalancer/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/amaliujia/DB-LoadBalancer/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/amaliujia/DB-LoadBalancer" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h3>
<a id="welcome-to-github-pages" class="anchor" href="#welcome-to-github-pages" aria-hidden="true"><span class="octicon octicon-link"></span></a>Proposal</h3>

<p><h4>Summary</h4>
We will create a load balancer for distributed key-value database as back-end. The database nodes will be used in this project is Emerald DB.
</p>
<p><h4>Background</h4>
Key-value (KV) stores use the associative array as their fundamental data model. In this model, data is represented as a collection of key-value pairs, such that each possible key appears at most once in the collection. Key-value database can provide us with many desirable attributes that relational database cannot provide, such as massive write performance, fast key-value access, flexible schema, no single point of failure, etc. Some big companies like Google and Yahoo use key-value database a lot and they often use several copies of one piece of data stored to obtain availability, reliability and parallel accessing. And sometimes for locality reason, they may move some copies from one database to another for locality reason. In this scenario, how to schedule data accessing among all these copies becomes a real-world problem and also the key to improve throughput. </p>

<p><h4>Challenge</h4>
The challenging part of this project is to correctly balance the request to the existing data copies. This requires us to get the real-time information of whether one database is overloaded or underloaded. Since we will considering the scenario that the locations of each data copies is not constant, which means that we will move certain data copies for load balancing reason. This post new challenge like where to place the data copies and how to adjust our scheduling policy. One of the biggest challenge is to ensure data consistency across different copies. There are already many algorithm which is specialized to handle the consistency problem, but trying to selecting most proper one to fit into our system is still challenging.
 </p>

<p><h4>Goals</h4>
The project has four main areas: implement load balancer, implement data movement mechanism, ensure data consistency and data access pattern related benchmark.</br>

<pre><code>$implement load balancer
Design and implement several scheduling policies
Using them under different load cases and find the general, near-optimal one.</code></pre>
<pre><code>$ensure data consistency
ensure that we always get a constant view across several data copies.
Using some mechanism like delay write propagation when back-end is underloaded to improve performance.</code></pre>
<pre><code>$implement data movement
Load balancer is the one who issues the movement command so we should properly integrate this functionality into load balancer.</code></pre>
	
<pre><code>$simulate real world use cases. 
simulate social network data access pattern.
simulate data access of high frequency transaction.</code></pre>
 </p>




<p><h4>Platform</h4>
We plan to implement our load balancer using Java under Linux environment. And the database we use is a document,  mongodb like database. The reason we choose this database is 1) Emerald DB is a pure and lightweight key-value database which makes it easy for us to integrate our own optimization. 2) This database is easy to make copie so we can simulate accessing multiple data copies. 3) Since it is very light-weight and we have gotten permission on code change. It is possible for us to modify this database and provide functionality that is necessary to our load-balancer </p>

      </section>
    </div>

    
  </body>
</html>